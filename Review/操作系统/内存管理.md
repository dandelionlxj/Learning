##   一、连续分配存储管理方式

指为用户进程分配的必须是一个连续的内存空间，有三种方式

（1）单一连续分配；（2）固定分区分配；（3）动态分区分配

###1、单一连续分配

  内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程和相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间

优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护

缺点：只能用于单用户、单任务的操作系统；有内部碎片；存储器利用率极低。

###2、固定分区分配

将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业



划分分区的方法有：

（1）分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合

（2）分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分



内存分配过程：

操作系统建立一个数据结构--分区说明表，来实现各个分区的分配和回收，当某用户要装入程序时，由操作系统内核程序根据用户程序的大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为已分配

###3、动态分区分配

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小刚好适合进程的需要，因此系统分区的大小和数目是可变的

动态分区分配没有内部碎片，但是有外部碎片

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上

外部碎片：是指内存中的某些空闲分区由于太小而难以利用



动态分区分配中的数据结构：

（1）空闲分区表； （2）空闲分区链 



**动态分区分配算法**：

**1、首次适应算法FF**

要求空闲分区链以地址递增的次序链接，每次从低地址开始查找，找到第一个能满足大小的空闲分区

**2、循环首次适应算法NF**

空闲分区以3地址递增的顺序排列，每次分配内存时从上次查找结束的位置开始查找空闲分区链，找到大小能满足要求的第一个空闲分区

优点：不用每次都从低地址的小分区开始检索，算法开销小

缺点：会使高地址的大分区也被用完

**3、最佳适应算法BF**

空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区

优点：会有更多的大分区被保留下来，更能满足大进程的需求

缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片

**4、最坏适应算法WF**

与最佳适应算法刚好相反，空闲分区按容量递减次序链接，每次分配时顺序查找空闲分区链，找到大小能满足的第一个空闲分期怒

优点：可以减少难以利用的小碎片

缺点：虽然可以让分配后留下的空闲区更大，但是这种方式会导致较大的连续空间被迅速用完，如果之后有大进程到达，就没有分区可用了



##二、非连续分配管理方式

为用户进程分配的可以是一些分数的内存空间，分为三种方式

（1）分页存储管理；（2）分段存储管理；（3）段页式存储管理

###1、分页存储管理

将内存空间分为一个个大小相等的分区，每个分区就是一个物理块或页框，每个页框有一个编号，从0开始

将用户进程的地址空间也分为与页框大小相同的一个个区域，称为页或页面，每个页面也有一个编号，即页号。也是从0开始

优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片

缺点：不方便按照逻辑模块实现信息的共享和保护



###2、分段存储管理

为了满足用户要求而形成的一种存储管理方式。它把用户程序的饿地址空间分为若干个大小不同的段，每段可定义一组相对完整的信息。在存储区分配时，以段为单位，这些段在内存中可以不相邻接，所以也同样实现了离散分配

优点：很方便按照逻辑模块实现信息的共享和保护

缺点：如果段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生外部碎片



###3、段页式管理

分段和分页相结合，将进程按照逻辑模块分段，再将各段分页



## 三、虚拟内存

虚拟内存的最大容量是计算机cpu寻址范围确定的

虚拟内存的实际容量=min（内存和外存之和，cpu寻址范围）

![1565769094257](C:\Users\ziji\AppData\Roaming\Typora\typora-user-images\1565769094257.png)



**虚拟存储器特征**：

（1）多次性：一个作业中的程序和数据允许被分成多次调入内存运行

（2）对换性：一个作业中的程序和数据无需在作业运行时常驻内存，而是允许在作业运行过程中，将作业换入、换出。（内存到外存）

（3）虚拟性：从逻辑上扩充了内存的容量，使用户看大的内存容量，远大于实际的容量



**虚拟内存的实现：**

### 1、请求分页存储管理

建立在基本分页基础上，为了能支持虚拟存储器功能，而增加了请求调页功能和页面置换功能

#### ①页面置换算法

**（1）最佳置换算法（OPT）**

选择淘汰的页面将是以后永不使用，或者是在最长时间内不再被访问的页面，这样可以保证最低的缺页率

缺页率最小，性能最好，但无法实现

**（2）先进先出置换算法（FIFO）**

每次淘汰的是页面是最早进入内存的页面

实现简单，但性能很差

**（3）最近最久未使用置换算法（LRU）**

每次淘汰的页面是最近最久未使用

性能很好，但需要硬件之间，算法开销打

**（4）时钟置换算法（CLOCK）**

最近未用算法

![1565770879864](C:\Users\ziji\AppData\Roaming\Typora\typora-user-images\1565770879864.png)

**（5）改进型的CLOCK置换算法**



#### ②抖动现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，产生的主要原因是进程频繁访问的页面数目高于可用的物理块数



### 2、请求分段存储管理

### 3、请求段页式存储管理

