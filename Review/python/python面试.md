## 1、深拷贝和浅拷贝

```python
import copy
a = [1, 2, 3, 4, ['a', 'b']] 
b = a # 引用，除非直接给a重新赋值，否则a变则b变，b变则a变
c = copy.copy(a) # 浅拷贝，只会拷贝父对象， 不会拷贝父对象中的子对象，所以若a的子对象变则c 变,但是父对象变                    c不会变
d = copy.deepcopy(a) #深拷贝，完全拷贝，完全独立于原对象，a变也不变
a.append(5) 
a[4].append('c') 

# 结果
# a:[1,2, 3, 4, ['a', 'b', 'c'], 5]
# b:[1,2, 3, 4, ['a', 'b', 'c'], 5]
# c:[1,2, 3, 4, ['a', 'b', 'c']]
# d:[1, 2, 3, 4, ['a', 'b']] 

# 总结
# 赋值后，a怎么变b就怎么变
# 浅拷贝，父对象变，c不变，子对象变才跟着变，子对象其实就是可以看做是a内嵌套的内容
# 深拷贝，只拷贝第一次，之后不论a怎么变都不会变，
```



## 2、Python中单下划线和双下划线：

（1）以单下划线开头（_foo），表名这是一个保护成员，只有类对象和子类对象自己能访问到这些变量

​       以单下划线开头的变量和函数被默认是内部函数，使用from module import *时不会被获取，但是使用import module可以获取。

（2）以单下划线结尾（foo_）仅仅是为了区别该名称与关键词

（3） 以双下划綫开头（__foo），表示为私有成员，只允许类本身访问，子类不能访问，用 \_classname\_\_foo来代替这个名字，以区别其他类相同的命名	

（4） 双下划线开头，双下划线结尾（\_\_foo\_\_）。一种约定，Python内部的名字，用来区别其他用户自定义的命名,以防冲突。是一些 Python 的“魔术”对象，表示这是一个特殊成员，例如：定义类的时候，若是添加__init__方法，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初使化，Python不建议将自己命名的方法写为这种形式。即以双下划线开头的方法和变量不会被继承



## 3、python中\_\_new\_\_()与\_\_init\_\_()的区别

1. 首先用法不同，

   \_\_new\_\_()用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法；

  　而 \_\_init\_\_() 用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。

由此可知，\_\_new\_\_()在\_\_init__() 之前被调用。如果\_\_new\_\_() 创建的是当前类的实例，会自动调用\_\_init\_\_()函数，通过return调用的\_\_new\_\_()的参数cls来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的\_\_init\_\_()函数



2.其次传入参数不同

　　\_\_new\_\_()至少有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别；

　　\_\_init\_\_()至少有一个参数self，就是这个\_\_new\_\_()返回的实例，\_\_init\_\_()在\_\_new__()的基础上完成一些初始化的操作。



3.返回值不同

　　\_\_new__()必须有返回值，返回实例对象；

　　\_\_init__()不需要返回值。



## 4、python拼接字符串的方法

![1567583759709](C:\Users\ziji\AppData\Roaming\Typora\typora-user-images\1567583759709.png)



##5、@staticmethod和@classmethod

Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:

```python
def foo(x):
    print "executing foo(%s)"%(x)

class A(object):
    def foo(self,x):
        print "executing foo(%s,%s)"%(self,x)

    @classmethod
    def class_foo(cls,x):
        print "executing class_foo(%s,%s)"%(cls,x)

    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)"%x

a=A()
```

 定义这些方法时的区别:

1、类的普通方法，需要一个self参数表示自身

2、@staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样

3、@classmethod也不需要表示自身对象的self参数，但需要有表示自身类的参数cls



方法内部：

1. 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。
2. 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。
3. 如果需要调用带self的方法，必须得先对类进行实例化。

应用场景：

1、如果在方法中不需要访问任何实例方法和属性，纯粹地通过传入参数并返回数据的功能性方法，那么就适合用静态方法来定义，节省了实例化对象的开销成本

2、如果定义了静态方法的类为父类，那么如果这个父类被删除了，调用子类方法的时候就会报错



[链接](https://blog.csdn.net/changkai456/article/details/80372198)

