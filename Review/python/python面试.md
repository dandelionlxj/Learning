## 1、深拷贝和浅拷贝

```python
import copy
a = [1, 2, 3, 4, ['a', 'b']] 
b = a # 引用，除非直接给a重新赋值，否则a变则b变，b变则a变
c = copy.copy(a) # 浅拷贝，只会拷贝父对象， 不会拷贝父对象中的子对象，所以若a的子对象变则c 变,但是父对象变                    c不会变
d = copy.deepcopy(a) #深拷贝，完全拷贝，完全独立于原对象，a变也不变
a.append(5) 
a[4].append('c') 

# 结果
# a:[1,2, 3, 4, ['a', 'b', 'c'], 5]
# b:[1,2, 3, 4, ['a', 'b', 'c'], 5]
# c:[1,2, 3, 4, ['a', 'b', 'c']]
# d:[1, 2, 3, 4, ['a', 'b']] 

# 总结
# 赋值后，a怎么变b就怎么变
# 浅拷贝，父对象变，c不变，子对象变才跟着变，子对象其实就是可以看做是a内嵌套的内容
# 深拷贝，只拷贝第一次，之后不论a怎么变都不会变，
```



## 2、Python中单下划线和双下划线：

（1）以单下划线开头（_foo），表名这是一个保护成员，只有类对象和子类对象自己能访问到这些变量

​       以单下划线开头的变量和函数被默认是内部函数，使用from module import *时不会被获取，但是使用import module可以获取。

（2）以单下划线结尾（foo_）仅仅是为了区别该名称与关键词

（3） 以双下划綫开头（__foo），表示为私有成员，只允许类本身访问，子类不能访问，用 \_classname\_\_foo来代替这个名字，以区别其他类相同的命名	

（4） 双下划线开头，双下划线结尾（\_\_foo\_\_）。一种约定，Python内部的名字，用来区别其他用户自定义的命名,以防冲突。是一些 Python 的“魔术”对象，表示这是一个特殊成员，例如：定义类的时候，若是添加__init__方法，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初使化，Python不建议将自己命名的方法写为这种形式。即以双下划线开头的方法和变量不会被继承



## 3、python中\_\_new\_\_()与\_\_init\_\_()的区别

1. 首先用法不同，

   \_\_new\_\_()用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法；

  　而 \_\_init\_\_() 用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。

由此可知，\_\_new\_\_()在\_\_init__() 之前被调用。如果\_\_new\_\_() 创建的是当前类的实例，会自动调用\_\_init\_\_()函数，通过return调用的\_\_new\_\_()的参数cls来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的\_\_init\_\_()函数



2.其次传入参数不同

　　\_\_new\_\_()至少有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别；

　　\_\_init\_\_()至少有一个参数self，就是这个\_\_new\_\_()返回的实例，\_\_init\_\_()在\_\_new__()的基础上完成一些初始化的操作。



3.返回值不同

　　\_\_new__()必须有返回值，返回实例对象；

　　\_\_init__()不需要返回值。